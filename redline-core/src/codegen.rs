use crate::lexer::Token;
use std::fmt;

#[derive(Debug)]
pub struct CodegenError {
    pub message: String,
}

impl fmt::Display for CodegenError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

pub fn generate(tokens: &[Token]) -> Result<String, CodegenError> {
    let mut cpp_code = String::new();
    let includes = String::from(
        "// Generated by REDLINE Core\n#include \"stdlib/rl_io.hpp\"\n#include <string>\n\n",
    );
    let mut main_body = String::new();
    let mut i = 0;
    let mut open_braces = 0;

    while i < tokens.len() {
        match &tokens[i] {
            Token::If => {
                i += 1; // Consume 'if'
                let mut condition = String::new();
                while i < tokens.len() && tokens[i] != Token::Colon && tokens[i] != Token::Newline {
                    match &tokens[i] {
                        Token::Ident(v) => condition.push_str(v),
                        Token::Int(n) => condition.push_str(&n.to_string()),
                        Token::Op(o) => {
                            condition.push(' ');
                            condition.push_str(o);
                            condition.push(' ');
                        }
                        _ => return Err(CodegenError { message: format!("Unexpected token in if condition: {:?}", tokens[i]) }),
                    }
                    i += 1;
                }

                if i < tokens.len() && tokens[i] == Token::Colon {
                    i += 1; // Consume ':'
                } else {
                    return Err(CodegenError { message: "Expected ':' after if condition".to_string() });
                }

                main_body.push_str(&format!("    if ({}) {{\n", condition));
                open_braces += 1;
            }
            Token::Else => {
                i += 1; // Consume 'else'
                // Optional colon after else
                if i < tokens.len() && tokens[i] == Token::Colon {
                    i += 1; // Consume ':'
                }
                main_body.push_str("    } else {\n");
            }
            Token::Val | Token::Var => {
                let is_const = tokens[i] == Token::Val;
                i += 1; // Consume 'val' or 'var'

                let name = if let Some(Token::Ident(n)) = tokens.get(i) {
                    n.clone()
                } else {
                    return Err(CodegenError { message: "Expected identifier after var/val".to_string() });
                };
                i += 1;

                if tokens.get(i) != Some(&Token::Colon) {
                    return Err(CodegenError { message: "Expected ':' after identifier in declaration".to_string()});
                }
                i += 1;

                let t = if let Some(Token::Type(ty)) = tokens.get(i) {
                    if ty == "string" { "std::string" } else { ty }
                } else {
                    return Err(CodegenError { message: "Expected type in declaration".to_string()});
                };
                i += 1;
                
                if tokens.get(i) != Some(&Token::Assign) {
                    return Err(CodegenError { message: "Expected '=' in declaration".to_string()});
                }
                i += 1;

                let mut val_str = String::new();
                while i < tokens.len() && tokens[i] != Token::Newline {
                    match &tokens[i] {
                        Token::Int(n) => val_str.push_str(&n.to_string()),
                        Token::Str(s) => val_str.push_str(&format!("\"{}\"", s)),
                        Token::Ident(v) => val_str.push_str(v),
                        Token::Op(o) => val_str.push_str(o),
                        _ => return Err(CodegenError { message: format!("Unexpected token in value assignment: {:?}", tokens[i]) }),
                    }
                    i += 1;
                }
                let prefix = if is_const { "const " } else { "" };
                main_body.push_str(&format!("    {}{} {} = {};\n", prefix, t, name, val_str));
            }
            Token::Print => {
                i += 1; // Consume 'print'
                if tokens.get(i) != Some(&Token::LParen) {
                    return Err(CodegenError { message: "Expected '(' after print".to_string()});
                }
                i += 1;

                let arg = match tokens.get(i) {
                    Some(Token::Str(s)) => format!("\"{}\"", s),
                    Some(Token::Ident(n)) => n.clone(),
                    Some(Token::Int(n)) => n.to_string(),
                    _ => return Err(CodegenError { message: "Invalid or missing argument for print".to_string() }),
                };
                i += 1;

                if tokens.get(i) != Some(&Token::RParen) {
                    return Err(CodegenError { message: "Expected ')' after print argument".to_string()});
                }
                i += 1;

                main_body.push_str(&format!("    rl::print({});\n", arg));
            }
            Token::Newline => {
                i += 1;
            }
            _ => {
                return Err(CodegenError{ message: format!("Unexpected token: {:?}", tokens[i])});
            }
        }
    }

    while open_braces > 0 {
        main_body.push_str("    }\n");
        open_braces -= 1;
    }

    cpp_code.push_str(&includes);
    cpp_code.push_str("int main() {\n");
    cpp_code.push_str(&main_body);
    cpp_code.push_str("    return 0;\n}\n");

    Ok(cpp_code)
}
