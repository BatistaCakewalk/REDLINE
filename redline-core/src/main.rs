use std::fs;
use std::env;

#[derive(Debug, Clone, PartialEq)]
enum Token {
    Let, Def, Print, Ident(String), Int(i64), Str(String), Type(String),
    Op(char), Colon, Assign, LParen, RParen, Comma, Newline,
}

struct Lexer { input: Vec<char>, pos: usize }

impl Lexer {
    fn new(input: String) -> Self { Self { input: input.chars().collect(), pos: 0 } }
    fn tokenize(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();
        while self.pos < self.input.len() {
            let c = self.input[self.pos];
            match c {
                ' ' | '\r' | '\t' => { self.pos += 1; } 
                '\n' => { tokens.push(Token::Newline); self.pos += 1; }
                ':' => { tokens.push(Token::Colon); self.pos += 1; }
                '=' => { tokens.push(Token::Assign); self.pos += 1; }
                '(' => { tokens.push(Token::LParen); self.pos += 1; }
                ')' => { tokens.push(Token::RParen); self.pos += 1; }
                ',' => { tokens.push(Token::Comma); self.pos += 1; }
                '+' | '-' | '*' | '/' => { tokens.push(Token::Op(c)); self.pos += 1; }
                '#' => { while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1; } }
                '"' => {
                    self.pos += 1;
                    let mut s = String::new();
                    while self.pos < self.input.len() && self.input[self.pos] != '"' {
                        s.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    tokens.push(Token::Str(s));
                    self.pos += 1;
                }
                _ if c.is_alphabetic() => {
                    let mut ident = String::new();
                    while self.pos < self.input.len() && (self.input[self.pos].is_alphanumeric() || self.input[self.pos] == '_') {
                        ident.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    match ident.as_str() {
                        "let" => tokens.push(Token::Let),
                        "def" => tokens.push(Token::Def),
                        "print" => tokens.push(Token::Print),
                        "int" | "float" | "string" => tokens.push(Token::Type(ident)),
                        _ => tokens.push(Token::Ident(ident)),
                    }
                }
                _ if c.is_numeric() => {
                    let mut num = String::new();
                    while self.pos < self.input.len() && self.input[self.pos].is_numeric() {
                        num.push(self.input[self.pos]);
                        self.pos += 1;
                    }
                    tokens.push(Token::Int(num.parse().unwrap()));
                }
                _ => { self.pos += 1; }
            }
        }
        tokens
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 { return; }
    let content = fs::read_to_string(&args[1]).expect("Fail");
    let tokens = Lexer::new(content).tokenize();

    let mut output = String::from("// Generated by REDLINE\n#include \"stdlib/rl_io.hpp\"\n#include <string>\n\n");
    let mut functions = String::new();
    let mut main_body = String::new();
    let mut i = 0;

    while i < tokens.len() {
        match &tokens[i] {
            Token::Def => {
                if let Token::Ident(name) = &tokens[i+1] {
                    functions.push_str(&format!("void {}(", name));
                    i += 3;
                    while tokens[i] != Token::RParen {
                        if let Token::Ident(p_n) = &tokens[i] {
                            let p_t = if let Token::Type(t) = &tokens[i+2] { if t == "string" { "std::string" } else { t } } else { "int" };
                            functions.push_str(&format!("{} {}", p_t, p_n));
                            i += 3;
                        }
                        if tokens[i] == Token::Comma { functions.push_str(", "); i += 1; }
                    }
                    functions.push_str(") {\n");
                    i += 2; // Skip ) and :
                    // Simple body parser: collect until newline followed by non-indented line
                    while i < tokens.len() && tokens[i] != Token::Def && tokens[i] != Token::Let {
                         if tokens[i] == Token::Print {
                            let arg = match &tokens[i+2] {
                                Token::Str(s) => format!("\"{}\"", s),
                                Token::Ident(n) => n.clone(),
                                Token::Int(v) => v.to_string(),
                                _ => "".to_string(),
                            };
                            functions.push_str(&format!("    rl::print({});\n", arg));
                            i += 3;
                         }
                         i += 1;
                    }
                    functions.push_str("}\n\n");
                }
            },
            Token::Let => {
                if let Token::Ident(name) = &tokens[i+1] {
                    let t = if let Token::Type(ty) = &tokens[i+3] { if ty == "string" { "std::string" } else { ty } } else { "int" };
                    let mut val = String::new();
                    i += 5;
                    while i < tokens.len() && tokens[i] != Token::Newline {
                        match &tokens[i] {
                            Token::Int(n) => val.push_str(&n.to_string()),
                            Token::Str(s) => val.push_str(&format!("\"{}\"", s)),
                            Token::Ident(v) => val.push_str(v),
                            Token::Op(o) => val.push(*o),
                            _ => {}
                        }
                        i += 1;
                    }
                    main_body.push_str(&format!("    {} {} = {};\n", t, name, val));
                }
            },
            Token::Print => {
                let arg = match &tokens[i+2] {
                    Token::Str(s) => format!("\"{}\"", s),
                    Token::Ident(n) => n.clone(),
                    Token::Int(v) => v.to_string(),
                    _ => "".to_string(),
                };
                main_body.push_str(&format!("    rl::print({});\n", arg));
                i += 3;
            },
            Token::Ident(name) => {
                if i + 1 < tokens.len() && tokens[i+1] == Token::LParen {
                    let mut args = String::new();
                    i += 2;
                    while tokens[i] != Token::RParen {
                        match &tokens[i] {
                            Token::Ident(n) => args.push_str(n),
                            Token::Int(v) => args.push_str(&v.to_string()),
                            Token::Str(s) => args.push_str(&format!("\"{}\"", s)),
                            _ => {}
                        }
                        if tokens[i+1] == Token::Comma { args.push_str(", "); i += 1; }
                        i += 1;
                    }
                    main_body.push_str(&format!("    {}({});\n", name, args));
                }
            }
            _ => i += 1,
        }
    }
    println!("{}{}\nint main() {{\n{}    return 0;\n}}", output, functions, main_body);
}
